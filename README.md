# Задание 1: Анализ и проектирование

## Подзадание 1.1: Анализ и планирование

### 1. Функциональность монолитного приложения

**Управление отоплением:**  
- Пользователи могут удалённо включать/выключать отопление в своих домах.
- Пользователи могут устанавливать желаемую температуру.
- Система автоматически поддерживает заданную температуру, регулируя подачу тепла.

**Мониторинг температуры:**  
- Система получает данные о температуре с датчиков, установленных в домах.
- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.

### 2. Анализ архитектуры монолитного приложения

- **Язык программирования**: Java - строго типизированный объектно-ориентированный язык программирования общего назначения. Является популярным языком, есть зрелые фреймворки и много готовых примеров.
- **База данных**: PostgreSQL - свободная объектно-реляционная СУБД. Могут быть сложности при настройке.
- **Архитектура**: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.  
Проблемы монолита: 
  - Высокий риск ошибок
  - Длительные циклы разработки и развёртывания
  - Трудно управлять командой
  - Трудно масштабировать отдельные компоненты системы
- **Взаимодействие**: Синхронное, запросы обрабатываются последовательно.  
Плюсы: простота, прозрачность.  
Минусы: зависимость от доступности, узкое место производительности.
- **Развертывание**: Требует остановки всего приложения. Возникает недоступность приложения при развертывании.

### 3. Определение доменов и границ контекстов

- **Домен: управление устройствами**
    - Поддомен: управление отоплением
        - Контекст: включение\выключение устройства
        - Контекст: установка необходимой температуры
    - Поддомен: автоматическое поддержание температуры
      - Контекст: регулировка подачи тепла  
<br/>  

- **Домен: мониторинг температуры**
    - Поддомен: приём данных с датчиков
        - Контекст: получение данных с датчиков о температуре
    - Поддомен: отображение данных пользователю
        - Контекст: отображение текущей температуры в доме пользователя

### 4. Визуализация контекста системы

[C4 диаграмма (System Context diagram), визуализирующая взаимодействие монолитного приложения с внешним миром](diagrams/context/SmartHome_Context.puml)


## Подзадание 1.2: Архитектура микросервисов

### 1. Декомпозиция на микросервисы

- **Телеметрия** - микросервис занимающийся информацией поступающей с датчиков.
- **Управление устройствами** - микросервис занимающийся ведением перечня датчиков и выполнение команд пользователя.
- **Управления пользователями** - микросервис отвечающий за управление пользователями.  
<br/>  

### 2. Определение взаимодействия

- Все запросы клиентов поступают в API Gateway.
- API Gateway маршрутизирует запросы микросервисам согласно роутингу.
- Микросервисы взаимодействуют с устройствами через модули. Модуль и микросервис общаются через шину данных (kafka).
- Микросервисы хранят данные, которые заведены пользователями и получены от датчиков, в БД.  
<br/>  

### 3 Визуализация архитектуры

[C4 — Уровень контейнеров (Containers)](diagrams/container/SmartHome_Container.puml)

[C4 — Уровень компонентов (Components)](diagrams/component/SmartHome_Component.puml)

[C4 — Уровень кода (Code)](diagrams/code/SmartHome_Code.puml)

## Подзадание 1.3: ER-диаграмма

### 1 Идентификация сущностей

- Пользователь (User)
- Дом (House)
- Устройство (Device)
- Тип устройства (DeviceType)
- Модуль (Module)
- Телеметрия (Telemetry)

### 2 Определение атрибутов

**Сущность "Дом (House)"**

- `id` — уникальный идентификатор дома.
- `user_id` — идентификатор пользователя — внешний ключ к таблице `User`.
- `address` — адрес дома.  
<br/>  

**Сущность "Пользователь (User)"**

- `id` — уникальный идентификатор пользователя.
- `name` — имя пользователя.  
<br/>  

**Сущность "Модуль (Module)"**

- `id` — уникальный идентификатор модуля.
- `house_id` — идентификатор дома, в котором установлен модуль — внешний ключ к таблице `House`.
- `device_type_id` — идентификатор типа устройства — внешний ключ к таблице `DeviceType`.
- `serial_number` — серийный номер модуля.
- `title` — название модуля.  
<br/>  

**Сущность "Тип устройства (DeviceType)"**

- `id` — уникальный идентификатор типа устройства.
- `code` — код типа устройства.
- `description` — описание типа устройства.  
<br/>  

**Сущность "Устройство (Device)"**

- `id` — уникальный идентификатор устройства.
- `module_id` — идентификатор модуля, к которому подключено устройство — внешний ключ к таблице `Module`.
- `serial_number` — серийный номер устройства.
- `status` — текущее состояние устройства (включено/выключено).  
<br/>  

**Сущность "Телеметрия (Telemetry)"**

- `id` — уникальный идентификатор данных телеметрии.
- `device_id` — идентификатор устройства, который отправляет данные — внешний ключ к таблице `Device`.
- `datetime` — дата и время получения данных
- `data` — данные  
<br/>  

### 3 Описание связей

- **Пользователь — Дом:** один-ко-многим, один пользователь может иметь доступ к нескольким домам, но каждый дом связан только с одним пользователем.
- **Модуль — Дом:** один-ко-многим, в одном доме может быть установлено несколько модулей, но каждый модуль связан только с одним домом.
- **Модуль — Тип устройства:** один-ко-многим, один тип устройства может быть у нескольких модулей, но к одному модулю могут быть подключены устройства только одного типа.
- **Устройство — Модуль:** один-ко-многим, к одному модулю могут быть подключены несколько устройств, но каждое устройство связано только с одним модулем.
- **Телеметрия — Устройство:** один-ко-многим, одно устройство генерирует несколько единиц данных телеметрии, но одна единица данных может быть создана только одним устройством.

### 4 Построение ER-диаграммы

[ER-диаграмма](diagrams/SmartHome_ER.puml)

## Подзадание 1.4: Создание и документирование API

### 1 Выбор типов API

В системе Умный дом будем использовать комбинированный тип API: REST API для взаимодействия с пользователем, а Async API для взаимодействия с устройствами.

### 2,4 Проектирование API для микросервиса «Управление устройствами»

**Пользовательский API**

<details>
  <summary>
    Создание типа устройства
  </summary>

- **Эндпойнт:** /device-types
- **Метод:** POST
- **Описание:** Создаёт тип устройства
- **Формат запроса:**
    - `code`
    - `description`
- **Формат ответа:**
    - `id`
- **Коды ответа:** 200 — успех, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/modules</td>
    <td>POST</td>
    <td>{"code": "heating", "description": "Контроль температуры"}</td>
    <td>200</td>
    <td>{"id": 1}</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Создание модуля
  </summary>

- **Эндпойнт:** /modules
- **Метод:** POST
- **Описание:** Создаёт модуль
- **Формат запроса:**
    - `house_id`
    - `device_type_id`
    - `serial_number`
    - `title`
- **Формат ответа:**
    - `id`
- **Коды ответа:** 200 — успех, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/modules</td>
    <td>POST</td>
    <td>{"house_id": 1, "device_type_id": 1, "serial_number": "m111", "title": "Модуль отопления"}</td>
    <td>200</td>
    <td>{"id": 1}</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Создание устройства
  </summary>

- **Эндпойнт:** /devices
- **Метод:** POST
- **Описание:** Создаёт устройство
- **Формат запроса:**
    - `module_id`
    - `serial_number`
- **Формат ответа:**
    - `id`
- **Коды ответа:** 200 — успех, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/devices</td>
    <td>POST</td>
    <td>{"module_id": 1, "serial_number": "d111"}</td>
    <td>200</td>
    <td>{"id": 1}</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Получение информации об устройстве
  </summary>

- **Эндпойнт:** /device/{device_id}
- **Метод:** GET
- **Описание:** Возвращает подробную информацию о конкретном устройстве по его ID.
- **Формат запроса:** -
- **Формат ответа:**
    - `id`
    - `module_id`
    - `serial_number`
    - `status`
- **Коды ответа:** 200 — успех, 404 — устройство не найдено, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/device/1</td>
    <td>GET</td>
    <td>-</td>
    <td>200</td>
    <td>{"id": 1, "module_id": 1, "serial_number": "111", "status": "off"}</td>
  </tr>
  <tr>
    <td>/device/11111</td>
    <td>GET</td>
    <td>-</td>
    <td>404</td>
    <td>"Устройство не найдено"</td>
  </tr>
  <tr>
    <td>/device/123400000000000000123123123</td>
    <td>GET</td>
    <td>-</td>
    <td>500</td>
    <td>"Ошибка сервера"</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Обновление состояния устройства
  </summary>

- **Эндпойнт:** /device/{device_id}/status
- **Метод:** PUT
- **Описание:** Обновляет статус устройства
- **Формат запроса:**
    - `status`
- **Формат ответа:** -
- **Коды ответа:** 200 — успех, 404 — устройство не найдено, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/device/1/status</td>
    <td>PUT</td>
    <td>{"status": "on"}</td>
    <td>200</td>
    <td>-</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Отправка команды устройству
  </summary>

- **Эндпойнт:** /device/{device_id}/commands
- **Метод:** POST
- **Описание:** Отправляет команду устройству
- **Формат запроса:**
    - `command`
- **Формат ответа:** -
- **Коды ответа:** 200 — успех, 404 — устройство не найдено, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/device/1/commands</td>
    <td>PUT</td>
    <td>{"command": "установить температуру 22 градуса"}</td>
    <td>200</td>
    <td>-</td>
  </tr>
</table>
</details>

**API для взаимодействия с устройствами**

<details>
  <summary>
    Отправка команды устройству
  </summary>

- **Топик:** devices.commands
- **Метод:** Publish
- **Описание:** Отправляет команду устройству
- **Формат сообщения:**
    - `device_id`
    - `command`
- **Примеры сообщений**

<table>
  <tr>
    <th>Топик</th>
    <th>Метод</th>
    <th>Сообщение</th>
  </tr>
  <tr>
    <td>devices.commands</td>
    <td>Publish</td>
    <td>{"device_id": 1, "command": "установить температуру 22 градуса"}</td>
  </tr>
</table>
</details>

### 3,4 Проектирование API для микросервиса «Телеметрия»

**Пользовательский API**

<details>
  <summary>
    Получение последних данных телеметрии
  </summary>

- **Эндпойнт:** /telemetry/latest?device={device_id}
- **Метод:** GET
- **Описание:** Возвращает последнее полученное значение телеметрии для устройства.
- **Формат запроса:** -
- **Формат ответа:**
    - `id`
    - `device_id`
    - `datetime`
    - `data`
- **Коды ответа:** 200 — успех, 404 — данные не найдены, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/devices/1/telemetry/latest</td>
    <td>GET</td>
    <td>-</td>
    <td>200</td>
    <td>{"id": 1, "device_id": 1, "datetime": 1727210751214, "data": {"temperature": "22C"}}</td>
  </tr>
  <tr>
    <td>/devices/11111telemetry/latest</td>
    <td>GET</td>
    <td>-</td>
    <td>404</td>
    <td>"Устройство не найдено"</td>
  </tr>
</table>
</details>

<details>
  <summary>
    Получение исторических данных телеметрии
  </summary>

- **Эндпойнт:** /telemetry?device={device_id}&from={from}&until={until}
- **Метод:** GET
- **Описание:** Возвращает исторические данные телеметрии для устройства за определённый период времени.
- **Формат запроса:** -
- **Формат ответа:** список элементов
    - `id`
    - `device_id`
    - `datetime`
    - `data`
- **Коды ответа:** 200 — успех, 500 — ошибка сервера
- **Примеры запросов и ответов:**

<table>
  <tr>
    <th>Запрос</th>
    <th>Метод</th>
    <th>Тело запроса</th>
    <th>Код ответа</th>
    <th>Тело ответа</th>
  </tr>
  <tr>
    <td>/devices/1/telemetry?from=2024-09-23&until=2024-09-25</td>
    <td>GET</td>
    <td>-</td>
    <td>200</td>
    <td>[{"id": 1, "device_id": 1, "datetime": 1727210751214, "data": {"temperature": "22C"}}]</td>
  </tr>
  <tr>
    <td>/devices/11111/telemetry?from=2024-09-23&until=2024-09-25</td>
    <td>GET</td>
    <td>-</td>
    <td>404</td>
    <td>"Устройство не найдено"</td>
  </tr>
</table>
</details>

**API для взаимодействия с устройствами**

<details>
  <summary>
    Получение телеметрии
  </summary>

- **Топик:** telemetry
- **Метод:** Subscribe
- **Описание:** Получает данные телеметрии
- **Формат сообщения:**
    - `device_id`
    - `data`
- **Примеры сообщений**

<table>
  <tr>
    <th>Топик</th>
    <th>Метод</th>
    <th>Сообщение</th>
  </tr>
  <tr>
    <td>telemetry</td>
    <td>Subscribe</td>
    <td>{"device_id": 1, "data": {"temperature": "22C"}}</td>
  </tr>
</table>
</details>


### 5 Документирование API

[Open API](docs/open-api.yaml)

[Async API](docs/async-api.yaml)


# Задание 2 Разработка MVP

## Запуск
1. В файле `.env` установить переменную окружения `KAFKA_HOST`, ip адрес компьютера (localhost и 128.0.0.1 устанавливать нельзя).
2. Выполнить в корне проекта запуск скрипта `./test.sh`

## Подзадание 2.1: Новые микросервисы и интеграция с монолитом

1. Язык программирования - JS (Node JS)
2. Проекты лежат в директории telemetry-service и device-service
3. API разработано
4. Логика микросервисов реализована (in memory db)
5. Разработанное API поддерживает интеграцию с монолитом через REST и Kafka
6. Развертывание выполнено в docker-compose

## Подзадание 2.2: Подготовка 3rd party сервисов для связи микросервисов
1-2. Kafka развёрнута и настроена  
3-4. API Gateway Kong развёрнут и настроен  
5.Интеграция микросервисов выполнена  
6.MVP протестировано. Подготовлен файл. `test.sh`

# Задание 3: Автоматизация поставки (опционально)

Не сделано.

---

# Базовая настройка

## Запуск minikube

[Инструкция по установке](https://minikube.sigs.k8s.io/docs/start/)

```bash
minikube start
```


## Добавление токена авторизации GitHub

[Получение токена](https://github.com/settings/tokens/new)

```bash
kubectl create secret docker-registry ghcr --docker-server=https://ghcr.io --docker-username=<github_username> --docker-password=<github_token> -n default
```


## Установка API GW kusk

[Install Kusk CLI](https://docs.kusk.io/getting-started/install-kusk-cli)

```bash
kusk cluster install
```


## Настройка terraform

[Установите Terraform](https://yandex.cloud/ru/docs/tutorials/infrastructure-management/terraform-quickstart#install-terraform)


Создайте файл ~/.terraformrc

```hcl
provider_installation {
  network_mirror {
    url = "https://terraform-mirror.yandexcloud.net/"
    include = ["registry.terraform.io/*/*"]
  }
  direct {
    exclude = ["registry.terraform.io/*/*"]
  }
}
```

## Применяем terraform конфигурацию 

```bash
cd terraform
terraform apply
```

## Настройка API GW

```bash
kusk deploy -i api.yaml
```

## Проверяем работоспособность

```bash
kubectl port-forward svc/kusk-gateway-envoy-fleet -n kusk-system 8080:80
curl localhost:8080/hello
```


## Delete minikube

```bash
minikube delete
```
