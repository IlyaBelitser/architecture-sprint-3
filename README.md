# Задание 1: Анализ и проектирование

## Подзадание 1.1: Анализ и планирование

Проект "Smart Home Monolith" представляет собой монолитное приложение для управления отоплением и мониторинга температуры в умном доме. Пользователи могут удаленно включать/выключать отопление, устанавливать желаемую температуру и просматривать текущую температуру через веб-интерфейс.

### 1. Функциональность монолитного приложения

**Управление отоплением:**  
- Пользователи могут удалённо включать/выключать отопление в своих домах.
- Пользователи могут устанавливать желаемую температуру.
- Система автоматически поддерживает заданную температуру, регулируя подачу тепла.

**Мониторинг температуры:**  
- Система получает данные о температуре с датчиков, установленных в домах.
- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.

### 2. Анализ архитектуры монолитного приложения

- **Язык программирования**: Java - строго типизированный объектно-ориентированный язык программирования общего назначения. Является популярным языком, есть зрелые фреймворки и много готовых примеров.
- **База данных**: PostgreSQL - свободная объектно-реляционная СУБД. Могут быть сложности при настройке.
- **Архитектура**: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.  
- Плюсы монолита:
  - Одна кодовая база (легче разрабатывать и отлаживать)
  - Проще тестировать
  - Производительность и эффективность
  - Одна база данных
  - Снижение издержек на обслуживание инфраструктуры
- Минусы монолита:
  - Высокий риск ошибок
  - Длительные циклы разработки и развёртывания
  - Трудно управлять командой
  - Ограничения в стеке технологий
  - Трудно масштабировать отдельные компоненты системы
- **Взаимодействие**: Синхронное, запросы обрабатываются последовательно.  
Плюсы: простота, прозрачность.  
Минусы: зависимость от доступности, узкое место производительности.
- **Развертывание**: Требует остановки всего приложения. Возникает недоступность приложения при развертывании.

### 3. Определение доменов и границ контекстов

- **Домен: управление устройствами**
    - Поддомен: управление отоплением
        - Контекст: включение\выключение устройства
        - Контекст: установка необходимой температуры
    - Поддомен: автоматическое поддержание температуры
      - Контекст: регулировка подачи тепла  
<br/>  

- **Домен: мониторинг температуры**
    - Поддомен: приём данных с датчиков
        - Контекст: получение данных с датчиков о температуре
    - Поддомен: отображение данных пользователю
        - Контекст: отображение текущей температуры в доме пользователя

### 4. Визуализация контекста системы AsIs

[C4 диаграмма (System Context diagram), визуализирующая взаимодействие монолитного приложения с внешним миром](docs/diagrams/AsIs/context/SmartHome_Context.puml)

[C4 диаграмма (Container diagram), визуализирующая контейнер монолитного приложения Умный дом](docs/diagrams/AsIs/container/SmartHome_Container.puml)

[C4 диаграмма (Component diagram), визуализирующая компонент API Application монолитного приложения Умный дом](docs/diagrams/AsIs/component/SmartHome_Component_ApiApplication.puml)

### План перехода к микросервисной архитектуре

В силу того, что в будущей системе пользователь сможет самостоятельно подключать датчики к системе и есть возможность осуществить прямую интеграцию, то создание ACL (anti-corruption layer) не целесообразно.
Как только новая система будет готова к внедрению, пользователю предоставляется две версии приложений (spa, mobile app): версия приложений для бэкенд-монолита (старая система) и версия приложений для бэкенд-микросервисы (будущая система).
У будущей системы будут предоставляться REST endpoint "/devices/{deviceId}/status" и REST endpoint "/telemetry", которые позволят осуществить прямую интеграцию будущей системы со старой системой.
Компания представить определенное время, чтобы пользователи перенастроили свои датчики на будущую систему или компания предоставит специалистов, которые помогу перенастроить пользователям свои датчики.

## Подзадание 1.2: Архитектура микросервисов

### 1. Декомпозиция на микросервисы

- **API Gateway** - маршрутизирует внешние запросы микросервисам, балансирует нагрузки, осуществляет аутентификацию, авторизацию и кеширование.
- **User Service** - управляет данными о пользователях, ролях и разрешениях пользователя. Хранит данные о пользователях, ролях и разрешениях пользователя в базе данных PostgreSQL.
- **Device Service** - Управляет данными об устройствах, отправляет команды на устройства. Хранит данные об устройствах в базе данных PostgreSQL.
- **House Service** - управляет данными о домах и модулях. Хранит данные о домах и модулях в базе данных PostgreSQL.
- **Telemetry Service** - осуществляет сбор и анализ телеметрии с устройств. Хранит телеметрию с устройств в базе данных InfluxDB (в проекте используется PostgreSQL для простоты).
- **Scenario Service** - управляет данными о сценариях использования устройств. Хранит данные о сценариях использования устройств в базе данных PostgreSQL.
<br/>  

### 2. Определение взаимодействия

- **API Gateway** направляет запросы к **User Service** для чтения/записи данных о пользователе, роли и разрешении.
- **User Service** читает/сохраняет данные в базу данных **User DB**.  

- **API Gateway** направляет запросы к **Device Service** для чтения/записи данных о устройстве.
- **Device Service** направляет запросы к **House Service** на проверку существования идентификатора модуля устройства.
- **Device Service** направляет запросы к **Scenario Service** на проверку существования идентификатора сценария использования устройства у .
- **Device Service** направляет запросы к **Telemetry Service** на получение IP адреса устройства.
- **Device Service** читает/сохраняет данные в базу данных **Device DB**.
- **API Gateway** направляет запросы к **Device Service** на передачу команды на устройство.
- **Device Service** отправляет команду на соответсвующее устройство.  

- **API Gateway** направляет запросы к **House Service** для чтения/записи данных о доме и модуле.  
- **House Service** направляет запросы к **User Service** на проверку существования идентификатора пользователя.
- **House Service** направляет запросы к **Device Service** на проверку существования идентификатора типа устройства.
- **House Service** читает/сохраняет данные о доме и модуле в базу данных **House DB**.  

- **API Gateway** направляет запросы к **Telemetry Service** для чтения/записи телеметрии устройства.  
- **Telemetry Service** направляет запросы к **Device Service** на проверку существования идентификатора устройства.
- **Telemetry Service** читает/сохраняет телеметрию в базу данных **Telemetry DB**.

- **API Gateway** направляет запросы к **Scenario Service** для чтения/записи сценарий использования устройства.
- **Scenario Service** направляет запросы к **User Service** на проверку существования идентификатора пользователя.
- **Scenario Service** направляет запросы к **Device Service** на проверку существования идентификатора устройства.
- **Scenario Service** направляет запросы к **Device Service** на передачу команды на устройство по заданным сценариям использования устройств. 
- **Scenario Service** читает/сохраняет сценарии работы устройства в базу данных **Scenario DB**.

### 3 Визуализация архитектуры ToBe

[C4 — Уровень контекста (Context)](docs/diagrams/ToBe/context/SmartHome_Context.puml)

[C4 — Уровень контейнеров (Containers)](docs/diagrams/ToBe/container/SmartHome_Container.puml)

[C4 — Уровень компонента Device service (Components)](docs/diagrams/ToBe/component/SmartHome_Component_DeviceService.puml)

[C4 — Уровень компонента Telemetry service (Components)](docs/diagrams/ToBe/component/SmartHome_Component_TelemetryService.puml)

[C4 — Уровень кода Device service (Code)](docs/diagrams/ToBe/code/SmartHome_Code_DeviceService.puml)

[C4 — Уровень кода Telemetry service (Code)](docs/diagrams/ToBe/code/SmartHome_Code_TelemetryService.puml)

## Подзадание 1.3: ER-диаграмма

### 1 Идентификация сущностей

- Пользователь (User)
- Роль (Role)
- Разрешение (Permission)
- Устройство (Device)
- Тип устройства (DeviceType)
- Дом (House)
- Модуль (Module)
- Тип модуля (ModuleType)
- Телеметрия (Telemetry)
- Сценарий (Scenario)

### 2 Определение атрибутов

**Сущность "Пользователь (User)"**

- `Id` — уникальный идентификатор пользователя
- `UserName` — имя пользователя
- `Email` — e-mail пользователя
- `Password` — пароль пользователя
- `Token` — токен пользователя
<br/>

**Сущность "Роль (Role)"**

- `Id` — уникальный идентификатор роли
- `Name` — имя роли
- `Description` — описание роли
- `AssignedAt` — дата и время назначения роли
<br/>

**Сущность "Разрешение (Permission)"**

- `Id` — уникальный идентификатор разрешения
- `Name` — название разрешения
- `Description` — описание разрешения
- `GrantedAt` — дата и время предоставления разрешения
<br/>

**Сущность "Дом (House)"**

- `Id` — уникальный идентификатор дома
- `UserId` — идентификатор пользователя, которому принадлежит дом — внешний ключ к таблице `User`
- `Name` — название дома
- `Address` — адрес дома
<br/>  

**Сущность "Модуль (Module)"**

- `Id` — уникальный идентификатор модуля
- `ModuleTypeId` — идентификатор типа модуля — внешний ключ к таблице `ModuleType`
- `HouseId` — идентификатор дома, в котором установлен модуль — внешний ключ к таблице `House`
- `DeviceTypeId` — идентификатор типа устройства данного модуля — внешний ключ к таблице `DeviceType`
- `Name` — название модуля
- `SerialNumber` — серийный номер модуля
<br/>  

**Сущность "Тип модуля (ModuleType)"**

- `Id` — уникальный идентификатор типа модуля
- `Name` — название типа модуля
- `Description` — описание типа модуля
<br/>

**Сущность "Устройство (Device)"**

- `Id` — уникальный идентификатор устройства
- `DeviceTypeId` — идентификатор типа устройства — внешний ключ к таблице `DeviceType`
- `ModuleId` — идентификатор модуля, к которому подключено устройство — внешний ключ к таблице `Module`
- `ScenarioId` — идентификатор сценария использования устройства, который будет выполняться на данном устройстве — внешний ключ к таблице `Scenario`
- `Name` — название устройства
- `SerialNumber` — серийный номер устройства
- `CurrentValue` — текущее значение устройства
- `TargetValue` — целевое значение устройства
- `Status` — текущее состояние устройства (включено/выключено)
<br/>

**Сущность "Тип устройства (DeviceType)"**

- `Id` — уникальный идентификатор типа устройства
- `Name` — название типа устройства
- `Description` — описание типа устройства
<br/>  

- **Сущность "Телеметрия (Telemetry)"**

- `Id` — уникальный идентификатор телеметрии
- `DeviceId` — идентификатор устройства, который отправляет телеметрию — внешний ключ к таблице `Device`
- `Data` — данные телеметрии
- `ReceivedAt` — дата и время получения телеметрии
- `IpAndPort` — значение ip адреса и порта устройства, который отправляет телеметрию
<br/>

- **Сущность "Сценарий (Scenario)"**

- `Id` — уникальный идентификатор сценария использования устройства
- `UserId` — идентификатор пользователя, к которому привязан сценарий — внешний ключ к таблице `User` 
- `Name` — название сценария использования устройства
- `Description` — описание сценария использования устройства
- `Script` — сценарий использования устройства
- `CreatedAt` — дата и время создания сценария использования устройства
- `UpdatedAt` — дата и время обновления сценария использования устройства

### 3 Описание связей

- **Пользователь — Роль:** многие-ко-многим, несколько пользователей могут иметь несколько ролей, несколько ролей могут иметь несколько пользователей.
- **Роль — Разрешение:** многие-ко-многим, несколько ролей могут иметь несколько разрешений, несколько разрешений могут иметь несколько ролей.
- **Пользователь — Дом:** один-ко-многим, один пользователь может иметь доступ к нескольким домам, но каждый дом связан только с одним пользователем.
- **Дом — Модуль:** один-ко-многим, в одном доме может быть установлено несколько модулей, но каждый модуль связан только с одним домом.
- **Тип модуля — Модуль:** один-ко-многим, один тип модуля может быть у нескольких модулей, но у одного модуля может быть только один тип модуля.
- **Тип устройства — Модуль:** один-к-одному, один тип устройства может быть у нескольких модулей, но к одному модулю могут быть подключены устройства только одного типа.
- **Модуль — Устройство:** один-ко-многим, к одному модулю могут быть подключены несколько устройств, но каждое устройство может подключено только с одним модулем.
- **Тип устройства — Устройство:** один-ко-многим, один тип устройства может быть у нескольких устройств, но у одного устройства может быть только один тип устройства.
- **Устройство — Телеметрия:** один-ко-многим, одно устройство генерирует несколько единиц данных телеметрии, но одна единица данных телеметрии может быть создана только одним устройством.
- **Сценарий — Устройство:** один-ко-многим, у одного сценария использования устройства может быть несколько устройств, но каждое устройство может только один сценарий использования устройства.
- **Пользователь — Сценарий:** один-ко-многим, у одного пользователя могут быть много сценариев использования устройства, но каждый сценарий использования устройства привязан только к одному пользователь.

### 4 Построение ER-диаграммы

[ER-диаграмма](docs/diagrams/ToBe/SmartHome_ER.puml)

## Подзадание 1.4: Создание и документирование API

В системе Умный дом будем использовать REST API для взаимодействия между микросервисами, а так же внешними устройствами.

[Device Service API](docs/api/DeviceServiceApi.yml)

[Telemetry Service API](docs/api/TelemetryServiceApi.yml)

# Задание 2 Разработка MVP

## Запуск
```bash
docker-compose up -d --build
```

## Тестирование API
Чтобы протестировать API, необходимо выполнить в корне проекта скрипт:
```
./test_api.sh
```

## Остановка
```bash
docker-compose down -v
```

## Подзадание 2.1: Новые микросервисы и интеграция с монолитом

1. Язык программирования - Java
2. Проекты лежат в директории smart-home-microservice (telemetry-service и device-service)
3. Разработанную API можно посмотреть с помощью Swagger микросервисов (/swagger-ui/index.html)
4. Реализована логика микросервисов, информация сохраняется в базе данных PostgreSQL
5. Разработанное API поддерживает интеграцию с монолитом через REST API
6. Развертывание выполнено в docker-compose

## Подзадание 2.2: Подготовка 3rd party сервисов для связи микросервисов
1-2. Kafka не используется  
3-4. API Gateway Kong развёрнут и настроен. Был выбран Kong, т.к. он позволяит в будущем добавлять устройтсва, работающими по протоколам MQTT и WebSocket.  
5.Интеграция настроена напрямую между микросервисами  
6.MVP протестировано. Подготовлен файл `test_api.sh`

# Задание 3: Автоматизация поставки (опционально)

Не сделано.
